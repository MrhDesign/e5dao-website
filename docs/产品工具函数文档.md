# 产品工具函数文档

## 📋 概述

产品工具函数库 (`lib/productUtils.ts`) 提供了一系列用于产品数据处理和操作的实用函数。这些函数专为 E5DAO 企业官网的产品管理系统设计，提供高效、类型安全的产品数据处理能力。

### 核心功能
- **分类关联查询**: 根据产品获取分类信息
- **分类检索**: 通过 slug 快速定位分类
- **产品筛选**: 按分类筛选产品数据
- **类型安全**: 完整的 TypeScript 类型支持
- **高性能**: 优化的查找算法

## 🛠️ 工具函数详解

### 1. getCategoryByProduct

#### 1.1 函数签名
```typescript
export const getCategoryByProduct = (
  product: Product, 
  categories: ProductCategory[]
): ProductCategory | undefined
```

#### 1.2 功能描述
根据产品对象获取其所属的分类信息。通过产品的 `categoryId` 在分类数组中查找匹配的分类。

#### 1.3 参数说明
| 参数 | 类型 | 描述 |
|------|------|------|
| `product` | `Product` | 产品对象（必须包含 categoryId） |
| `categories` | `ProductCategory[]` | 分类数组 |

#### 1.4 返回值
- **类型**: `ProductCategory | undefined`
- **成功**: 返回匹配的分类对象
- **失败**: 当找不到匹配分类时返回 `undefined`

#### 1.5 实现原理
```typescript
export const getCategoryByProduct = (product: Product, categories: ProductCategory[]): ProductCategory | undefined => {
  return categories.find(cat => cat.id === product.categoryId);
};
```

**算法特点**:
- 使用 `Array.find()` 方法进行线性查找
- 时间复杂度: O(n)，其中 n 为分类数量
- 空间复杂度: O(1)

#### 1.6 使用示例
```typescript
import { getCategoryByProduct } from '@/lib/productUtils';
import useContent from '@/lib/useContent';

const ProductDetail = () => {
  const { getContent } = useContent();
  const categoriesData = getContent<ProductCategory[]>('products.categories') || [];
  const product = getContent<Product>('products.items[0]'); // 获取第一个产品

  // 获取产品所属分类
  const category = getCategoryByProduct(product, categoriesData);
  
  if (category) {
    console.log(`产品属于分类: ${category.title}`);
    console.log(`分类 slug: ${category.slug}`);
  } else {
    console.warn(`未找到产品 ${product.id} 的分类`);
  }

  return (
    <div>
      {category && (
        <p>产品分类: {category.title}</p>
      )}
    </div>
  );
};
```

#### 1.7 错误处理
```typescript
const ProductComponent = ({ product }: { product: Product }) => {
  const categoriesData = getContent<ProductCategory[]>('products.categories') || [];
  const category = getCategoryByProduct(product, categoriesData);

  if (!category) {
    // 处理分类不存在的情况
    console.error(`Category not found for product ${product.id} with categoryId ${product.categoryId}`);
    return <div>分类信息不可用</div>;
  }

  return <div>产品分类: {category.title}</div>;
};
```

### 2. getCategoryBySlug

#### 2.1 函数签名
```typescript
export const getCategoryBySlug = (
  slug: string, 
  categories: ProductCategory[]
): ProductCategory | undefined
```

#### 2.2 功能描述
根据分类的 URL slug 获取完整的分类信息。主要用于动态路由解析，将 URL 中的分类标识符转换为完整的分类对象。

#### 2.3 参数说明
| 参数 | 类型 | 描述 |
|------|------|------|
| `slug` | `string` | 分类的 URL 标识符 |
| `categories` | `ProductCategory[]` | 分类数组 |

#### 2.4 返回值
- **类型**: `ProductCategory | undefined`
- **成功**: 返回匹配的分类对象
- **失败**: 当找不到匹配 slug 的分类时返回 `undefined`

#### 2.5 实现原理
```typescript
export const getCategoryBySlug = (slug: string, categories: ProductCategory[]): ProductCategory | undefined => {
  return categories.find(cat => cat.slug === slug);
};
```

**算法特点**:
- 字符串精确匹配查找
- 区分大小写的匹配逻辑
- 优化的单次遍历查找

#### 2.6 使用示例

##### 在动态路由中使用
```typescript
// app/products/[category]/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { getCategoryBySlug } from '@/lib/productUtils';

export default function CategoryPage() {
  const params = useParams();
  const categorySlug = params.category as string;
  const { getContent } = useContent();
  
  const categoriesData = getContent<ProductCategory[]>('products.categories') || [];
  const category = getCategoryBySlug(categorySlug, categoriesData);

  if (!category) {
    return <div>分类不存在</div>;
  }

  return (
    <div>
      <h1>{category.title}</h1>
      <p>分类 ID: {category.id}</p>
      <p>分类 Slug: {category.slug}</p>
    </div>
  );
}
```

##### 在面包屑导航中使用
```typescript
const BreadcrumbComponent = ({ categorySlug }: { categorySlug: string }) => {
  const { getContent } = useContent();
  const categoriesData = getContent<ProductCategory[]>('products.categories') || [];
  const category = getCategoryBySlug(categorySlug, categoriesData);

  return (
    <nav>
      <Link href="/products">Products</Link>
      {category && (
        <>
          <span> / </span>
          <Link href={`/products/${category.slug}`}>{category.title}</Link>
        </>
      )}
    </nav>
  );
};
```

#### 2.7 分类验证应用
```typescript
// 在产品详情页验证分类一致性
const validateProductCategory = (product: Product, categorySlug: string, categories: ProductCategory[]) => {
  const urlCategory = getCategoryBySlug(categorySlug, categories);
  const productCategory = getCategoryByProduct(product, categories);
  
  return urlCategory && productCategory && urlCategory.id === productCategory.id;
};

// 使用示例
const ProductDetailPage = () => {
  const params = useParams();
  const categorySlug = params.category as string;
  const productId = parseInt(params.id as string);
  
  const { getContent } = useContent();
  const categoriesData = getContent<ProductCategory[]>('products.categories') || [];
  const productsData = getContent<Product[]>('products.items') || [];
  
  const product = productsData.find(p => p.id === productId);
  
  if (!product) {
    return <div>产品不存在</div>;
  }
  
  // 验证URL分类与产品分类是否一致
  if (!validateProductCategory(product, categorySlug, categoriesData)) {
    return <div>产品分类不匹配</div>;
  }
  
  return <div>产品详情页面</div>;
};
```

### 3. getProductsByCategory

#### 3.1 函数签名
```typescript
export const getProductsByCategory = (
  products: Product[], 
  categoryId: number
): Product[]
```

#### 3.2 功能描述
根据分类 ID 筛选出该分类下的所有产品。用于分类页面的产品展示、相关产品推荐等场景。

#### 3.3 参数说明
| 参数 | 类型 | 描述 |
|------|------|------|
| `products` | `Product[]` | 产品数组 |
| `categoryId` | `number` | 目标分类的 ID |

#### 3.4 返回值
- **类型**: `Product[]`
- **成功**: 返回该分类下的产品数组
- **空结果**: 当没有匹配产品时返回空数组 `[]`

#### 3.5 实现原理
```typescript
export const getProductsByCategory = (products: Product[], categoryId: number): Product[] => {
  return products.filter(product => product.categoryId === categoryId);
};
```

**算法特点**:
- 使用 `Array.filter()` 方法进行过滤
- 时间复杂度: O(n)，其中 n 为产品总数
- 返回新数组，不修改原数组

#### 3.6 使用示例

##### 分类页面产品展示
```typescript
// app/products/[category]/page.tsx
const CategoryProductsPage = () => {
  const params = useParams();
  const categorySlug = params.category as string;
  const { getContent } = useContent();
  
  const categoriesData = getContent<ProductCategory[]>('products.categories') || [];
  const productsData = getContent<Product[]>('products.items') || [];
  
  // 1. 根据 slug 获取分类信息
  const category = getCategoryBySlug(categorySlug, categoriesData);
  
  if (!category) {
    return <div>分类不存在</div>;
  }
  
  // 2. 获取该分类下的所有产品
  const categoryProducts = getProductsByCategory(productsData, category.id);
  
  return (
    <div>
      <h1>{category.title}</h1>
      <div className="grid grid-cols-2 lg:grid-cols-4 gap-2.5 lg:gap-10">
        {categoryProducts.map((product) => (
          <ProductCard
            key={product.id}
            product={product}
            className="w-full"
          />
        ))}
      </div>
      {categoryProducts.length === 0 && (
        <p>该分类下暂无产品</p>
      )}
    </div>
  );
};
```

##### 相关产品推荐
```typescript
const RelatedProducts = ({ currentProduct }: { currentProduct: Product }) => {
  const { getContent } = useContent();
  const productsData = getContent<Product[]>('products.items') || [];
  
  // 获取同分类的所有产品
  const categoryProducts = getProductsByCategory(productsData, currentProduct.categoryId);
  
  // 排除当前产品，获取相关产品
  const relatedProducts = categoryProducts
    .filter(product => product.id !== currentProduct.id)
    .slice(0, 4); // 只显示4个相关产品
  
  return (
    <div>
      <h2>相关产品</h2>
      <div className="grid grid-cols-2 lg:grid-cols-4 gap-4">
        {relatedProducts.map((product) => (
          <ProductCard key={product.id} product={product} />
        ))}
      </div>
    </div>
  );
};
```

##### 分类统计信息
```typescript
const CategoryStats = () => {
  const { getContent } = useContent();
  const categoriesData = getContent<ProductCategory[]>('products.categories') || [];
  const productsData = getContent<Product[]>('products.items') || [];
  
  const categoryStats = categoriesData.map(category => ({
    ...category,
    productCount: getProductsByCategory(productsData, category.id).length
  }));
  
  return (
    <div>
      <h2>分类统计</h2>
      {categoryStats.map(category => (
        <div key={category.id}>
          <span>{category.title}: {category.productCount} 个产品</span>
        </div>
      ))}
    </div>
  );
};
```

#### 3.7 高级用法

##### 多条件筛选
```typescript
// 扩展函数：支持多条件筛选
const getProductsByFilters = (
  products: Product[],
  filters: {
    categoryId?: number;
    productType?: 'independent-rd' | 'standard';
    hasGallery?: boolean;
  }
): Product[] => {
  return products.filter(product => {
    if (filters.categoryId && product.categoryId !== filters.categoryId) {
      return false;
    }
    
    if (filters.productType && product.productType !== filters.productType) {
      return false;
    }
    
    if (filters.hasGallery !== undefined) {
      const hasGallery = product.gallery && product.gallery.length > 0;
      if (hasGallery !== filters.hasGallery) {
        return false;
      }
    }
    
    return true;
  });
};

// 使用示例
const filteredProducts = getProductsByFilters(productsData, {
  categoryId: 1,
  productType: 'independent-rd',
  hasGallery: true
});
```

## 🚀 性能优化

### 1. 缓存优化
```typescript
import { useMemo } from 'react';

const ProductListComponent = () => {
  const { getContent } = useContent();
  const productsData = getContent<Product[]>('products.items') || [];
  const categoriesData = getContent<ProductCategory[]>('products.categories') || [];
  
  // 缓存分类产品映射
  const categoryProductsMap = useMemo(() => {
    const map = new Map<number, Product[]>();
    categoriesData.forEach(category => {
      map.set(category.id, getProductsByCategory(productsData, category.id));
    });
    return map;
  }, [productsData, categoriesData]);
  
  // 快速获取分类产品
  const getCachedCategoryProducts = (categoryId: number): Product[] => {
    return categoryProductsMap.get(categoryId) || [];
  };
  
  return (
    <div>
      {categoriesData.map(category => (
        <div key={category.id}>
          <h3>{category.title}</h3>
          <p>{getCachedCategoryProducts(category.id).length} 个产品</p>
        </div>
      ))}
    </div>
  );
};
```

### 2. 索引优化
```typescript
// 为大量数据创建索引
class ProductIndex {
  private categoryIndex = new Map<number, Product[]>();
  private slugIndex = new Map<string, ProductCategory>();
  
  constructor(products: Product[], categories: ProductCategory[]) {
    this.buildCategoryIndex(products);
    this.buildSlugIndex(categories);
  }
  
  private buildCategoryIndex(products: Product[]) {
    products.forEach(product => {
      const categoryProducts = this.categoryIndex.get(product.categoryId) || [];
      categoryProducts.push(product);
      this.categoryIndex.set(product.categoryId, categoryProducts);
    });
  }
  
  private buildSlugIndex(categories: ProductCategory[]) {
    categories.forEach(category => {
      this.slugIndex.set(category.slug, category);
    });
  }
  
  getCategoryBySlug(slug: string): ProductCategory | undefined {
    return this.slugIndex.get(slug);
  }
  
  getProductsByCategory(categoryId: number): Product[] {
    return this.categoryIndex.get(categoryId) || [];
  }
}

// 使用索引
const productIndex = new ProductIndex(productsData, categoriesData);
const category = productIndex.getCategoryBySlug('command-system');
const products = productIndex.getProductsByCategory(1);
```

## 🧪 测试建议

### 1. 单元测试
```typescript
import { getCategoryByProduct, getCategoryBySlug, getProductsByCategory } from '@/lib/productUtils';

describe('productUtils', () => {
  const mockCategories: ProductCategory[] = [
    { id: 1, title: 'Command System', slug: 'command-system' },
    { id: 2, title: 'Medical System', slug: 'medical-system' }
  ];
  
  const mockProducts: Product[] = [
    {
      id: 1,
      categoryId: 1,
      productType: 'independent-rd',
      title: 'Product 1',
      description: 'Description 1',
      image: '/img1.jpg',
      alt: 'Product 1'
    },
    {
      id: 2,
      categoryId: 1,
      productType: 'standard',
      model: 'PROD-002',
      standardCategory: 'Standard',
      image: '/img2.jpg',
      alt: 'Product 2'
    }
  ];

  describe('getCategoryByProduct', () => {
    it('should return correct category for product', () => {
      const result = getCategoryByProduct(mockProducts[0], mockCategories);
      expect(result).toEqual(mockCategories[0]);
    });
    
    it('should return undefined for non-existent category', () => {
      const productWithInvalidCategory = { ...mockProducts[0], categoryId: 999 };
      const result = getCategoryByProduct(productWithInvalidCategory, mockCategories);
      expect(result).toBeUndefined();
    });
  });

  describe('getCategoryBySlug', () => {
    it('should return correct category for slug', () => {
      const result = getCategoryBySlug('command-system', mockCategories);
      expect(result).toEqual(mockCategories[0]);
    });
    
    it('should return undefined for non-existent slug', () => {
      const result = getCategoryBySlug('non-existent', mockCategories);
      expect(result).toBeUndefined();
    });
  });

  describe('getProductsByCategory', () => {
    it('should return products in correct category', () => {
      const result = getProductsByCategory(mockProducts, 1);
      expect(result).toHaveLength(2);
      expect(result.every(p => p.categoryId === 1)).toBe(true);
    });
    
    it('should return empty array for non-existent category', () => {
      const result = getProductsByCategory(mockProducts, 999);
      expect(result).toEqual([]);
    });
  });
});
```

### 2. 集成测试
```typescript
describe('productUtils integration', () => {
  it('should work together for complete product workflow', () => {
    // 1. 通过 slug 获取分类
    const category = getCategoryBySlug('command-system', mockCategories);
    expect(category).toBeTruthy();
    
    // 2. 获取该分类的产品
    const categoryProducts = getProductsByCategory(mockProducts, category!.id);
    expect(categoryProducts.length).toBeGreaterThan(0);
    
    // 3. 验证产品与分类的关联
    const firstProduct = categoryProducts[0];
    const productCategory = getCategoryByProduct(firstProduct, mockCategories);
    expect(productCategory).toEqual(category);
  });
});
```

## 📚 最佳实践

### 1. 错误处理
```typescript
const safeGetCategoryByProduct = (
  product: Product, 
  categories: ProductCategory[]
): ProductCategory | null => {
  try {
    const category = getCategoryByProduct(product, categories);
    if (!category) {
      console.warn(`Category not found for product ${product.id} (categoryId: ${product.categoryId})`);
      return null;
    }
    return category;
  } catch (error) {
    console.error('Error getting category by product:', error);
    return null;
  }
};
```

### 2. 类型守护
```typescript
const isValidProduct = (product: any): product is Product => {
  return (
    typeof product === 'object' &&
    typeof product.id === 'number' &&
    typeof product.categoryId === 'number' &&
    typeof product.image === 'string' &&
    typeof product.alt === 'string' &&
    (product.productType === 'independent-rd' || product.productType === 'standard')
  );
};

const isValidCategory = (category: any): category is ProductCategory => {
  return (
    typeof category === 'object' &&
    typeof category.id === 'number' &&
    typeof category.title === 'string' &&
    typeof category.slug === 'string'
  );
};
```

### 3. 性能监控
```typescript
const performanceWrapper = <T extends any[], R>(
  fn: (...args: T) => R,
  name: string
) => {
  return (...args: T): R => {
    const start = performance.now();
    const result = fn(...args);
    const end = performance.now();
    
    if (end - start > 1) { // 如果执行时间超过1ms
      console.warn(`${name} took ${end - start}ms to execute`);
    }
    
    return result;
  };
};

// 使用性能包装器
export const performantGetProductsByCategory = performanceWrapper(
  getProductsByCategory,
  'getProductsByCategory'
);
```

---

*文档版本: v1.0*
*最后更新: 2025-09-04*
*维护者: Claude Code*