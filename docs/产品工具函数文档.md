# äº§å“å·¥å…·å‡½æ•°æ–‡æ¡£

## ğŸ“‹ æ¦‚è¿°

äº§å“å·¥å…·å‡½æ•°åº“ (`lib/productUtils.ts`) æä¾›äº†ä¸€ç³»åˆ—ç”¨äºäº§å“æ•°æ®å¤„ç†å’Œæ“ä½œçš„å®ç”¨å‡½æ•°ã€‚è¿™äº›å‡½æ•°ä¸“ä¸º E5DAO ä¼ä¸šå®˜ç½‘çš„äº§å“ç®¡ç†ç³»ç»Ÿè®¾è®¡ï¼Œæä¾›é«˜æ•ˆã€ç±»å‹å®‰å…¨çš„äº§å“æ•°æ®å¤„ç†èƒ½åŠ›ã€‚

### æ ¸å¿ƒåŠŸèƒ½
- **åˆ†ç±»å…³è”æŸ¥è¯¢**: æ ¹æ®äº§å“è·å–åˆ†ç±»ä¿¡æ¯
- **åˆ†ç±»æ£€ç´¢**: é€šè¿‡ slug å¿«é€Ÿå®šä½åˆ†ç±»
- **äº§å“ç­›é€‰**: æŒ‰åˆ†ç±»ç­›é€‰äº§å“æ•°æ®
- **ç±»å‹å®‰å…¨**: å®Œæ•´çš„ TypeScript ç±»å‹æ”¯æŒ
- **é«˜æ€§èƒ½**: ä¼˜åŒ–çš„æŸ¥æ‰¾ç®—æ³•

## ğŸ› ï¸ å·¥å…·å‡½æ•°è¯¦è§£

### 1. getCategoryByProduct

#### 1.1 å‡½æ•°ç­¾å
```typescript
export const getCategoryByProduct = (
  product: Product, 
  categories: ProductCategory[]
): ProductCategory | undefined
```

#### 1.2 åŠŸèƒ½æè¿°
æ ¹æ®äº§å“å¯¹è±¡è·å–å…¶æ‰€å±çš„åˆ†ç±»ä¿¡æ¯ã€‚é€šè¿‡äº§å“çš„ `categoryId` åœ¨åˆ†ç±»æ•°ç»„ä¸­æŸ¥æ‰¾åŒ¹é…çš„åˆ†ç±»ã€‚

#### 1.3 å‚æ•°è¯´æ˜
| å‚æ•° | ç±»å‹ | æè¿° |
|------|------|------|
| `product` | `Product` | äº§å“å¯¹è±¡ï¼ˆå¿…é¡»åŒ…å« categoryIdï¼‰ |
| `categories` | `ProductCategory[]` | åˆ†ç±»æ•°ç»„ |

#### 1.4 è¿”å›å€¼
- **ç±»å‹**: `ProductCategory | undefined`
- **æˆåŠŸ**: è¿”å›åŒ¹é…çš„åˆ†ç±»å¯¹è±¡
- **å¤±è´¥**: å½“æ‰¾ä¸åˆ°åŒ¹é…åˆ†ç±»æ—¶è¿”å› `undefined`

#### 1.5 å®ç°åŸç†
```typescript
export const getCategoryByProduct = (product: Product, categories: ProductCategory[]): ProductCategory | undefined => {
  return categories.find(cat => cat.id === product.categoryId);
};
```

**ç®—æ³•ç‰¹ç‚¹**:
- ä½¿ç”¨ `Array.find()` æ–¹æ³•è¿›è¡Œçº¿æ€§æŸ¥æ‰¾
- æ—¶é—´å¤æ‚åº¦: O(n)ï¼Œå…¶ä¸­ n ä¸ºåˆ†ç±»æ•°é‡
- ç©ºé—´å¤æ‚åº¦: O(1)

#### 1.6 ä½¿ç”¨ç¤ºä¾‹
```typescript
import { getCategoryByProduct } from '@/lib/productUtils';
import useContent from '@/lib/useContent';

const ProductDetail = () => {
  const { getContent } = useContent();
  const categoriesData = getContent<ProductCategory[]>('products.categories') || [];
  const product = getContent<Product>('products.items[0]'); // è·å–ç¬¬ä¸€ä¸ªäº§å“

  // è·å–äº§å“æ‰€å±åˆ†ç±»
  const category = getCategoryByProduct(product, categoriesData);
  
  if (category) {
    console.log(`äº§å“å±äºåˆ†ç±»: ${category.title}`);
    console.log(`åˆ†ç±» slug: ${category.slug}`);
  } else {
    console.warn(`æœªæ‰¾åˆ°äº§å“ ${product.id} çš„åˆ†ç±»`);
  }

  return (
    <div>
      {category && (
        <p>äº§å“åˆ†ç±»: {category.title}</p>
      )}
    </div>
  );
};
```

#### 1.7 é”™è¯¯å¤„ç†
```typescript
const ProductComponent = ({ product }: { product: Product }) => {
  const categoriesData = getContent<ProductCategory[]>('products.categories') || [];
  const category = getCategoryByProduct(product, categoriesData);

  if (!category) {
    // å¤„ç†åˆ†ç±»ä¸å­˜åœ¨çš„æƒ…å†µ
    console.error(`Category not found for product ${product.id} with categoryId ${product.categoryId}`);
    return <div>åˆ†ç±»ä¿¡æ¯ä¸å¯ç”¨</div>;
  }

  return <div>äº§å“åˆ†ç±»: {category.title}</div>;
};
```

### 2. getCategoryBySlug

#### 2.1 å‡½æ•°ç­¾å
```typescript
export const getCategoryBySlug = (
  slug: string, 
  categories: ProductCategory[]
): ProductCategory | undefined
```

#### 2.2 åŠŸèƒ½æè¿°
æ ¹æ®åˆ†ç±»çš„ URL slug è·å–å®Œæ•´çš„åˆ†ç±»ä¿¡æ¯ã€‚ä¸»è¦ç”¨äºåŠ¨æ€è·¯ç”±è§£æï¼Œå°† URL ä¸­çš„åˆ†ç±»æ ‡è¯†ç¬¦è½¬æ¢ä¸ºå®Œæ•´çš„åˆ†ç±»å¯¹è±¡ã€‚

#### 2.3 å‚æ•°è¯´æ˜
| å‚æ•° | ç±»å‹ | æè¿° |
|------|------|------|
| `slug` | `string` | åˆ†ç±»çš„ URL æ ‡è¯†ç¬¦ |
| `categories` | `ProductCategory[]` | åˆ†ç±»æ•°ç»„ |

#### 2.4 è¿”å›å€¼
- **ç±»å‹**: `ProductCategory | undefined`
- **æˆåŠŸ**: è¿”å›åŒ¹é…çš„åˆ†ç±»å¯¹è±¡
- **å¤±è´¥**: å½“æ‰¾ä¸åˆ°åŒ¹é… slug çš„åˆ†ç±»æ—¶è¿”å› `undefined`

#### 2.5 å®ç°åŸç†
```typescript
export const getCategoryBySlug = (slug: string, categories: ProductCategory[]): ProductCategory | undefined => {
  return categories.find(cat => cat.slug === slug);
};
```

**ç®—æ³•ç‰¹ç‚¹**:
- å­—ç¬¦ä¸²ç²¾ç¡®åŒ¹é…æŸ¥æ‰¾
- åŒºåˆ†å¤§å°å†™çš„åŒ¹é…é€»è¾‘
- ä¼˜åŒ–çš„å•æ¬¡éå†æŸ¥æ‰¾

#### 2.6 ä½¿ç”¨ç¤ºä¾‹

##### åœ¨åŠ¨æ€è·¯ç”±ä¸­ä½¿ç”¨
```typescript
// app/products/[category]/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { getCategoryBySlug } from '@/lib/productUtils';

export default function CategoryPage() {
  const params = useParams();
  const categorySlug = params.category as string;
  const { getContent } = useContent();
  
  const categoriesData = getContent<ProductCategory[]>('products.categories') || [];
  const category = getCategoryBySlug(categorySlug, categoriesData);

  if (!category) {
    return <div>åˆ†ç±»ä¸å­˜åœ¨</div>;
  }

  return (
    <div>
      <h1>{category.title}</h1>
      <p>åˆ†ç±» ID: {category.id}</p>
      <p>åˆ†ç±» Slug: {category.slug}</p>
    </div>
  );
}
```

##### åœ¨é¢åŒ…å±‘å¯¼èˆªä¸­ä½¿ç”¨
```typescript
const BreadcrumbComponent = ({ categorySlug }: { categorySlug: string }) => {
  const { getContent } = useContent();
  const categoriesData = getContent<ProductCategory[]>('products.categories') || [];
  const category = getCategoryBySlug(categorySlug, categoriesData);

  return (
    <nav>
      <Link href="/products">Products</Link>
      {category && (
        <>
          <span> / </span>
          <Link href={`/products/${category.slug}`}>{category.title}</Link>
        </>
      )}
    </nav>
  );
};
```

#### 2.7 åˆ†ç±»éªŒè¯åº”ç”¨
```typescript
// åœ¨äº§å“è¯¦æƒ…é¡µéªŒè¯åˆ†ç±»ä¸€è‡´æ€§
const validateProductCategory = (product: Product, categorySlug: string, categories: ProductCategory[]) => {
  const urlCategory = getCategoryBySlug(categorySlug, categories);
  const productCategory = getCategoryByProduct(product, categories);
  
  return urlCategory && productCategory && urlCategory.id === productCategory.id;
};

// ä½¿ç”¨ç¤ºä¾‹
const ProductDetailPage = () => {
  const params = useParams();
  const categorySlug = params.category as string;
  const productId = parseInt(params.id as string);
  
  const { getContent } = useContent();
  const categoriesData = getContent<ProductCategory[]>('products.categories') || [];
  const productsData = getContent<Product[]>('products.items') || [];
  
  const product = productsData.find(p => p.id === productId);
  
  if (!product) {
    return <div>äº§å“ä¸å­˜åœ¨</div>;
  }
  
  // éªŒè¯URLåˆ†ç±»ä¸äº§å“åˆ†ç±»æ˜¯å¦ä¸€è‡´
  if (!validateProductCategory(product, categorySlug, categoriesData)) {
    return <div>äº§å“åˆ†ç±»ä¸åŒ¹é…</div>;
  }
  
  return <div>äº§å“è¯¦æƒ…é¡µé¢</div>;
};
```

### 3. getProductsByCategory

#### 3.1 å‡½æ•°ç­¾å
```typescript
export const getProductsByCategory = (
  products: Product[], 
  categoryId: number
): Product[]
```

#### 3.2 åŠŸèƒ½æè¿°
æ ¹æ®åˆ†ç±» ID ç­›é€‰å‡ºè¯¥åˆ†ç±»ä¸‹çš„æ‰€æœ‰äº§å“ã€‚ç”¨äºåˆ†ç±»é¡µé¢çš„äº§å“å±•ç¤ºã€ç›¸å…³äº§å“æ¨èç­‰åœºæ™¯ã€‚

#### 3.3 å‚æ•°è¯´æ˜
| å‚æ•° | ç±»å‹ | æè¿° |
|------|------|------|
| `products` | `Product[]` | äº§å“æ•°ç»„ |
| `categoryId` | `number` | ç›®æ ‡åˆ†ç±»çš„ ID |

#### 3.4 è¿”å›å€¼
- **ç±»å‹**: `Product[]`
- **æˆåŠŸ**: è¿”å›è¯¥åˆ†ç±»ä¸‹çš„äº§å“æ•°ç»„
- **ç©ºç»“æœ**: å½“æ²¡æœ‰åŒ¹é…äº§å“æ—¶è¿”å›ç©ºæ•°ç»„ `[]`

#### 3.5 å®ç°åŸç†
```typescript
export const getProductsByCategory = (products: Product[], categoryId: number): Product[] => {
  return products.filter(product => product.categoryId === categoryId);
};
```

**ç®—æ³•ç‰¹ç‚¹**:
- ä½¿ç”¨ `Array.filter()` æ–¹æ³•è¿›è¡Œè¿‡æ»¤
- æ—¶é—´å¤æ‚åº¦: O(n)ï¼Œå…¶ä¸­ n ä¸ºäº§å“æ€»æ•°
- è¿”å›æ–°æ•°ç»„ï¼Œä¸ä¿®æ”¹åŸæ•°ç»„

#### 3.6 ä½¿ç”¨ç¤ºä¾‹

##### åˆ†ç±»é¡µé¢äº§å“å±•ç¤º
```typescript
// app/products/[category]/page.tsx
const CategoryProductsPage = () => {
  const params = useParams();
  const categorySlug = params.category as string;
  const { getContent } = useContent();
  
  const categoriesData = getContent<ProductCategory[]>('products.categories') || [];
  const productsData = getContent<Product[]>('products.items') || [];
  
  // 1. æ ¹æ® slug è·å–åˆ†ç±»ä¿¡æ¯
  const category = getCategoryBySlug(categorySlug, categoriesData);
  
  if (!category) {
    return <div>åˆ†ç±»ä¸å­˜åœ¨</div>;
  }
  
  // 2. è·å–è¯¥åˆ†ç±»ä¸‹çš„æ‰€æœ‰äº§å“
  const categoryProducts = getProductsByCategory(productsData, category.id);
  
  return (
    <div>
      <h1>{category.title}</h1>
      <div className="grid grid-cols-2 lg:grid-cols-4 gap-2.5 lg:gap-10">
        {categoryProducts.map((product) => (
          <ProductCard
            key={product.id}
            product={product}
            className="w-full"
          />
        ))}
      </div>
      {categoryProducts.length === 0 && (
        <p>è¯¥åˆ†ç±»ä¸‹æš‚æ— äº§å“</p>
      )}
    </div>
  );
};
```

##### ç›¸å…³äº§å“æ¨è
```typescript
const RelatedProducts = ({ currentProduct }: { currentProduct: Product }) => {
  const { getContent } = useContent();
  const productsData = getContent<Product[]>('products.items') || [];
  
  // è·å–åŒåˆ†ç±»çš„æ‰€æœ‰äº§å“
  const categoryProducts = getProductsByCategory(productsData, currentProduct.categoryId);
  
  // æ’é™¤å½“å‰äº§å“ï¼Œè·å–ç›¸å…³äº§å“
  const relatedProducts = categoryProducts
    .filter(product => product.id !== currentProduct.id)
    .slice(0, 4); // åªæ˜¾ç¤º4ä¸ªç›¸å…³äº§å“
  
  return (
    <div>
      <h2>ç›¸å…³äº§å“</h2>
      <div className="grid grid-cols-2 lg:grid-cols-4 gap-4">
        {relatedProducts.map((product) => (
          <ProductCard key={product.id} product={product} />
        ))}
      </div>
    </div>
  );
};
```

##### åˆ†ç±»ç»Ÿè®¡ä¿¡æ¯
```typescript
const CategoryStats = () => {
  const { getContent } = useContent();
  const categoriesData = getContent<ProductCategory[]>('products.categories') || [];
  const productsData = getContent<Product[]>('products.items') || [];
  
  const categoryStats = categoriesData.map(category => ({
    ...category,
    productCount: getProductsByCategory(productsData, category.id).length
  }));
  
  return (
    <div>
      <h2>åˆ†ç±»ç»Ÿè®¡</h2>
      {categoryStats.map(category => (
        <div key={category.id}>
          <span>{category.title}: {category.productCount} ä¸ªäº§å“</span>
        </div>
      ))}
    </div>
  );
};
```

#### 3.7 é«˜çº§ç”¨æ³•

##### å¤šæ¡ä»¶ç­›é€‰
```typescript
// æ‰©å±•å‡½æ•°ï¼šæ”¯æŒå¤šæ¡ä»¶ç­›é€‰
const getProductsByFilters = (
  products: Product[],
  filters: {
    categoryId?: number;
    productType?: 'independent-rd' | 'standard';
    hasGallery?: boolean;
  }
): Product[] => {
  return products.filter(product => {
    if (filters.categoryId && product.categoryId !== filters.categoryId) {
      return false;
    }
    
    if (filters.productType && product.productType !== filters.productType) {
      return false;
    }
    
    if (filters.hasGallery !== undefined) {
      const hasGallery = product.gallery && product.gallery.length > 0;
      if (hasGallery !== filters.hasGallery) {
        return false;
      }
    }
    
    return true;
  });
};

// ä½¿ç”¨ç¤ºä¾‹
const filteredProducts = getProductsByFilters(productsData, {
  categoryId: 1,
  productType: 'independent-rd',
  hasGallery: true
});
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### 1. ç¼“å­˜ä¼˜åŒ–
```typescript
import { useMemo } from 'react';

const ProductListComponent = () => {
  const { getContent } = useContent();
  const productsData = getContent<Product[]>('products.items') || [];
  const categoriesData = getContent<ProductCategory[]>('products.categories') || [];
  
  // ç¼“å­˜åˆ†ç±»äº§å“æ˜ å°„
  const categoryProductsMap = useMemo(() => {
    const map = new Map<number, Product[]>();
    categoriesData.forEach(category => {
      map.set(category.id, getProductsByCategory(productsData, category.id));
    });
    return map;
  }, [productsData, categoriesData]);
  
  // å¿«é€Ÿè·å–åˆ†ç±»äº§å“
  const getCachedCategoryProducts = (categoryId: number): Product[] => {
    return categoryProductsMap.get(categoryId) || [];
  };
  
  return (
    <div>
      {categoriesData.map(category => (
        <div key={category.id}>
          <h3>{category.title}</h3>
          <p>{getCachedCategoryProducts(category.id).length} ä¸ªäº§å“</p>
        </div>
      ))}
    </div>
  );
};
```

### 2. ç´¢å¼•ä¼˜åŒ–
```typescript
// ä¸ºå¤§é‡æ•°æ®åˆ›å»ºç´¢å¼•
class ProductIndex {
  private categoryIndex = new Map<number, Product[]>();
  private slugIndex = new Map<string, ProductCategory>();
  
  constructor(products: Product[], categories: ProductCategory[]) {
    this.buildCategoryIndex(products);
    this.buildSlugIndex(categories);
  }
  
  private buildCategoryIndex(products: Product[]) {
    products.forEach(product => {
      const categoryProducts = this.categoryIndex.get(product.categoryId) || [];
      categoryProducts.push(product);
      this.categoryIndex.set(product.categoryId, categoryProducts);
    });
  }
  
  private buildSlugIndex(categories: ProductCategory[]) {
    categories.forEach(category => {
      this.slugIndex.set(category.slug, category);
    });
  }
  
  getCategoryBySlug(slug: string): ProductCategory | undefined {
    return this.slugIndex.get(slug);
  }
  
  getProductsByCategory(categoryId: number): Product[] {
    return this.categoryIndex.get(categoryId) || [];
  }
}

// ä½¿ç”¨ç´¢å¼•
const productIndex = new ProductIndex(productsData, categoriesData);
const category = productIndex.getCategoryBySlug('command-system');
const products = productIndex.getProductsByCategory(1);
```

## ğŸ§ª æµ‹è¯•å»ºè®®

### 1. å•å…ƒæµ‹è¯•
```typescript
import { getCategoryByProduct, getCategoryBySlug, getProductsByCategory } from '@/lib/productUtils';

describe('productUtils', () => {
  const mockCategories: ProductCategory[] = [
    { id: 1, title: 'Command System', slug: 'command-system' },
    { id: 2, title: 'Medical System', slug: 'medical-system' }
  ];
  
  const mockProducts: Product[] = [
    {
      id: 1,
      categoryId: 1,
      productType: 'independent-rd',
      title: 'Product 1',
      description: 'Description 1',
      image: '/img1.jpg',
      alt: 'Product 1'
    },
    {
      id: 2,
      categoryId: 1,
      productType: 'standard',
      model: 'PROD-002',
      standardCategory: 'Standard',
      image: '/img2.jpg',
      alt: 'Product 2'
    }
  ];

  describe('getCategoryByProduct', () => {
    it('should return correct category for product', () => {
      const result = getCategoryByProduct(mockProducts[0], mockCategories);
      expect(result).toEqual(mockCategories[0]);
    });
    
    it('should return undefined for non-existent category', () => {
      const productWithInvalidCategory = { ...mockProducts[0], categoryId: 999 };
      const result = getCategoryByProduct(productWithInvalidCategory, mockCategories);
      expect(result).toBeUndefined();
    });
  });

  describe('getCategoryBySlug', () => {
    it('should return correct category for slug', () => {
      const result = getCategoryBySlug('command-system', mockCategories);
      expect(result).toEqual(mockCategories[0]);
    });
    
    it('should return undefined for non-existent slug', () => {
      const result = getCategoryBySlug('non-existent', mockCategories);
      expect(result).toBeUndefined();
    });
  });

  describe('getProductsByCategory', () => {
    it('should return products in correct category', () => {
      const result = getProductsByCategory(mockProducts, 1);
      expect(result).toHaveLength(2);
      expect(result.every(p => p.categoryId === 1)).toBe(true);
    });
    
    it('should return empty array for non-existent category', () => {
      const result = getProductsByCategory(mockProducts, 999);
      expect(result).toEqual([]);
    });
  });
});
```

### 2. é›†æˆæµ‹è¯•
```typescript
describe('productUtils integration', () => {
  it('should work together for complete product workflow', () => {
    // 1. é€šè¿‡ slug è·å–åˆ†ç±»
    const category = getCategoryBySlug('command-system', mockCategories);
    expect(category).toBeTruthy();
    
    // 2. è·å–è¯¥åˆ†ç±»çš„äº§å“
    const categoryProducts = getProductsByCategory(mockProducts, category!.id);
    expect(categoryProducts.length).toBeGreaterThan(0);
    
    // 3. éªŒè¯äº§å“ä¸åˆ†ç±»çš„å…³è”
    const firstProduct = categoryProducts[0];
    const productCategory = getCategoryByProduct(firstProduct, mockCategories);
    expect(productCategory).toEqual(category);
  });
});
```

## ğŸ“š æœ€ä½³å®è·µ

### 1. é”™è¯¯å¤„ç†
```typescript
const safeGetCategoryByProduct = (
  product: Product, 
  categories: ProductCategory[]
): ProductCategory | null => {
  try {
    const category = getCategoryByProduct(product, categories);
    if (!category) {
      console.warn(`Category not found for product ${product.id} (categoryId: ${product.categoryId})`);
      return null;
    }
    return category;
  } catch (error) {
    console.error('Error getting category by product:', error);
    return null;
  }
};
```

### 2. ç±»å‹å®ˆæŠ¤
```typescript
const isValidProduct = (product: any): product is Product => {
  return (
    typeof product === 'object' &&
    typeof product.id === 'number' &&
    typeof product.categoryId === 'number' &&
    typeof product.image === 'string' &&
    typeof product.alt === 'string' &&
    (product.productType === 'independent-rd' || product.productType === 'standard')
  );
};

const isValidCategory = (category: any): category is ProductCategory => {
  return (
    typeof category === 'object' &&
    typeof category.id === 'number' &&
    typeof category.title === 'string' &&
    typeof category.slug === 'string'
  );
};
```

### 3. æ€§èƒ½ç›‘æ§
```typescript
const performanceWrapper = <T extends any[], R>(
  fn: (...args: T) => R,
  name: string
) => {
  return (...args: T): R => {
    const start = performance.now();
    const result = fn(...args);
    const end = performance.now();
    
    if (end - start > 1) { // å¦‚æœæ‰§è¡Œæ—¶é—´è¶…è¿‡1ms
      console.warn(`${name} took ${end - start}ms to execute`);
    }
    
    return result;
  };
};

// ä½¿ç”¨æ€§èƒ½åŒ…è£…å™¨
export const performantGetProductsByCategory = performanceWrapper(
  getProductsByCategory,
  'getProductsByCategory'
);
```

---

*æ–‡æ¡£ç‰ˆæœ¬: v1.0*
*æœ€åæ›´æ–°: 2025-09-04*
*ç»´æŠ¤è€…: Claude Code*